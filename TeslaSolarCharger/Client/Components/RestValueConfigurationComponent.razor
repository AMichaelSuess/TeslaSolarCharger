@using TeslaSolarCharger.Shared.Dtos.RestValueConfiguration
@using TeslaSolarCharger.Shared.Helper.Contracts
@using TeslaSolarCharger.Shared.Resources.Contracts
@using TeslaSolarCharger.SharedModel.Enums
@using TeslaSolarCharger.Client.Wrapper
@using TeslaSolarCharger.Shared.Dtos
@using TeslaSolarCharger.Shared.Dtos.BaseConfiguration
@inject HttpClient HttpClient
@inject IConstants Constants
@inject IStringHelper StringHelper
@inject ISnackbar Snackbar

<h2>REST sources</h2>

<div class="d-flex flex-wrap justify-content-evenly">
    @foreach (var restConfigurationOverview in _restConfigurationOverviews)
    {
        <div class="align-self-center m-3">
            <MudCard>
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">
                            <TextShortenComponent InputString="@restConfigurationOverview.Url"
                                                  ShouldDisplayTruncatedCharCount="false"
                                                  MaxLength="25"
                                                  ShouldDisplayCopyButton="false"
                                                  TooltipText="@restConfigurationOverview.Url"></TextShortenComponent>
                        </MudText>
                    </CardHeaderContent>
                    <CardHeaderActions>
                        <MudTooltip>
                            <ChildContent>
                                <MudIconButton Icon="@Icons.Material.Filled.Refresh" Color="Color.Default" />
                            </ChildContent>
                            <TooltipContent>
                                <div>
                                    Refresh values
                                </div>
                            </TooltipContent>
                        </MudTooltip>
                    </CardHeaderActions>
                </MudCardHeader>
                <MudCardContent>
                    @foreach (var restValueResult in restConfigurationOverview.Results)
                    {
                        string suffixString;
                        <div class="d-flex align-items-center">
                            <div class="flex-grow-0">
                                @switch (restValueResult.UsedFor)
                                {
                                    case ValueUsage.InverterPower:
                                        <MudIcon Icon="@Icons.Material.Filled.SolarPower"></MudIcon>
                                        suffixString = "W";
                                        break;
                                    case ValueUsage.GridPower:
                                        <MudIcon Icon="@Constants.GridPoleIcon"></MudIcon>
                                        suffixString = "W";
                                        break;
                                    case ValueUsage.HomeBatteryPower:
                                        <MudIcon Icon="@Icons.Material.Filled.BatteryChargingFull"></MudIcon>
                                        suffixString = "W";
                                        break;
                                    case ValueUsage.HomeBatterySoc:
                                        <MudIcon Icon="@Icons.Material.Filled.Battery4Bar"></MudIcon>
                                        suffixString = "%";
                                        break;
                                    default:
                                        throw new ArgumentOutOfRangeException();
                                }
                            </div>
                            <div class="flex-grow-1">
                                <MudChip Text="grey">@(restValueResult.CalculatedValue == null ? "Not available" : Math.Round(restValueResult.CalculatedValue.Value, 2) + $" {suffixString}")</MudChip>
                            </div>
                        </div>
                    }
                </MudCardContent>
                <MudCardActions>
                    <MudButton Variant="Variant.Text" Color="Color.Primary">Configure</MudButton>
                </MudCardActions>
            </MudCard>
        </div>
    }
    <div class="align-self-center m-3">
        <MudCard>
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">
                        Add new REST source
                    </MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                <div class="d-flex justify-content-center">
                    <MudFab StartIcon="@Icons.Material.Filled.Add" Color="Color.Primary"></MudFab>
                </div>
                
            </MudCardContent>
            <MudCardActions>
                @* <MudButton Variant="Variant.Text" Color="Color.Primary">Configure</MudButton> *@
            </MudCardActions>
        </MudCard>
    </div>
</div>

@foreach (var editableItem in EditableItems)
{
    <div class="shadow p-3 mb-5 bg-white rounded">
        <h3>HTTP Request configuration</h3>
        <EditFormComponent T="DtoRestValueConfiguration" WrappedElement="editableItem" OnValidSubmit="(item) => HandleValidSubmit(item)">
            <ChildContent>
                <div class="p-2">
                    <MudSelect T="HttpVerb"
                               Class="@Constants.DefaultMargin"
                               Variant="Variant.Outlined"
                               Value="@editableItem.Item.HttpMethod"
                               ValueChanged="(newItem) => UpdateHttpVerb(editableItem.Item, newItem)"
                               Label="HTTP Method">
                        @foreach (HttpVerb item in Enum.GetValues(typeof(HttpVerb)))
                        {
                            <MudSelectItem T="HttpVerb" Value="@item">@StringHelper.GenerateFriendlyStringFromPascalString(item.ToString())</MudSelectItem>
                        }
                    </MudSelect>
                </div>
                <GenericInput T="string" For="() => editableItem.Item.Url" OnValueChanged="StateHasChanged"></GenericInput>
                <div class="p-2">
                    <MudSelect T="NodePatternType"
                               Class="@Constants.DefaultMargin"
                               Variant="Variant.Outlined"
                               Value="@editableItem.Item.NodePatternType"
                               ValueChanged="@((newValue) => UpdateNodePatternType(editableItem.Item, newValue))"
                               Label="Node Pattern Type">
                        @foreach (NodePatternType item in Enum.GetValues(typeof(NodePatternType)))
                        {
                            <MudSelectItem T="NodePatternType" Value="@item">@StringHelper.GenerateFriendlyStringFromPascalString(item.ToString())</MudSelectItem>
                        }
                    </MudSelect>
                </div>
            </ChildContent>
        </EditFormComponent>
        @if (editableItem.Item.Id != default && !editableItem.EditContext.IsModified())
        {
            <div class="shadow p-3 mb-5 bg-white rounded">
                <RestValueHeaderConfigurationComponent ParentId="editableItem.Item.Id"></RestValueHeaderConfigurationComponent>
            </div>
            <div class="shadow p-3 mb-5 bg-white rounded">
                <RestValueResultConfigurationComponent ParentId="editableItem.Item.Id"
                                                       NodePatternType="editableItem.Item.NodePatternType"></RestValueResultConfigurationComponent>
            </div>
        }
        else
        {
            <div class="p-2">
                Save Data to enable result configuration
            </div>

        }
    </div>
}
<RightAlignedButtonComponent ButtonText="Add REST Call"
                             IsDisabled="RestValueConfigurations.Any(r => r.Id == default)"
                             OnButtonClicked="() => RestValueConfigurations.Add(new DtoRestValueConfiguration())"></RightAlignedButtonComponent>

@code {
    private List<DtoRestConfigurationOverview> _restConfigurationOverviews = new();

    private List<DtoRestValueConfiguration> RestValueConfigurations { get; set; } = new();

    private List<EditableItem<DtoRestValueConfiguration>> EditableItems => RestValueConfigurations.Select(restValueConfiguration => new EditableItem<DtoRestValueConfiguration>(restValueConfiguration)).ToList();

    protected override async Task OnInitializedAsync()
    {
        await LoadRestValueConfigurations();
        await RefreshRequestResults();

    }

    private async Task LoadRestValueConfigurations()
    {
        var restValueConfigurations = await HttpClient.GetFromJsonAsync<List<DtoRestValueConfiguration>>("/api/RestValueConfiguration/GetAllRestValueConfigurations");
        RestValueConfigurations = restValueConfigurations ?? new List<DtoRestValueConfiguration>();
    }

    private void UpdateNodePatternType(DtoRestValueConfiguration restValueConfiguration, NodePatternType newItem)
    {
        restValueConfiguration.NodePatternType = newItem;
        StateHasChanged();
    }

    private void UpdateHttpVerb(DtoRestValueConfiguration restValueConfiguration, HttpVerb newItem)
    {
        restValueConfiguration.HttpMethod = newItem;
        StateHasChanged();
    }

    private async Task HandleValidSubmit(DtoRestValueConfiguration item)
    {
        var result = await HttpClient.PostAsJsonAsync("/api/RestValueConfiguration/UpdateRestValueConfiguration", item);
        if (!result.IsSuccessStatusCode)
        {
            Snackbar.Add("Failed to update REST value configuration", Severity.Error);
            return;
        }
        var resultContent = await result.Content.ReadFromJsonAsync<DtoValue<int>>();
        if (resultContent == default)
        {
            Snackbar.Add("Failed to update REST value configuration", Severity.Error);
            return;
        }

        Snackbar.Add("Rest value configuration saved.", Severity.Success);
        item.Id = resultContent.Value;
    }

    private Task<GridData<DtoRestValueConfiguration>> GetChildContent(GridState<DtoRestValueConfiguration> arg)
    {
        
        return Task.FromResult(new GridData<DtoRestValueConfiguration>
        {
            Items = new List<DtoRestValueConfiguration>(),
            TotalItems = 0
        });
    }

    private async Task<GridData<DtoRestValueConfigurationHeader>> GetHeaders(int itemId)
    {
        var elements = await HttpClient.GetFromJsonAsync<List<DtoRestValueConfigurationHeader>>($"api/RestValueConfiguration/GetHeadersByConfigurationId?parentId={itemId}");
        var result = elements ?? new List<DtoRestValueConfigurationHeader>();
        return new GridData<DtoRestValueConfigurationHeader>
        {
            Items = result,
            TotalItems = result.Count,
        };
    }

    private async Task<GridData<DtoRestValueResultConfiguration>> GetResultConfigurations(int itemId)
    {
        var elements = await HttpClient.GetFromJsonAsync<List<DtoRestValueResultConfiguration>>($"api/RestValueConfiguration/GetResultConfigurationsByConfigurationId?parentId={itemId}");
        var result = elements ?? new List<DtoRestValueResultConfiguration>();
        return new GridData<DtoRestValueResultConfiguration>
        {
            Items = result,
            TotalItems = result.Count,
        };
    }

    
    private async Task RefreshRequestResults()
    {
        _restConfigurationOverviews = await HttpClient.GetFromJsonAsync<List<DtoRestConfigurationOverview>>("api/BaseConfiguration/GetRestValueConfigurations") ?? new List<DtoRestConfigurationOverview>();
    }
}
